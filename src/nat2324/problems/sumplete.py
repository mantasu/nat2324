import numpy as np


class Sumplete:
    """Sumplete problem.

    This problem is to find the numbers that should be removed in a
    sumplete puzzle. A sumplete puzzle is a square grid of numbers where
    the sum of each row and column is given. The goal is to find the
    numbers to remove from the grid such that the sum of each row and
    column is equal.

    Args:
        K (int, optional): The size of the square grid. Defaults to 3.
        low (int, optional): The lowest possible number in the grid.
            Defaults to 1.
        high (int, optional): The highest possible number in the grid.
            Defaults to round(4 * np.log(k * k)).
        deletion_rate (float, optional): The probability of a number
            being deleted from the grid. Defaults to 1/3.
        evaluation_type (str, optional): The type of evaluation to use.
            Can be one of "absolute", "distance", "row_col", "cellular",
            or "mixed". Defaults to "absolute".
        seed (int, optional): The seed to use for the random number
            generator. Defaults to ``None``.
    """

    def __init__(
        self,
        K: int = (k := 3),
        low: int = 1,
        high: int = round(4 * np.log(k * k)),
        deletion_rate: float = 1 / 3,
        evaluation_type: str = "absolute",
        seed: int = None,
    ):
        # Initialize parameters
        self.K = K
        self.low = low
        self.high = high
        self.deletion_rate = deletion_rate
        self.evaluation_type = evaluation_type

        # Generate the game: new board, column sums, and row sums
        self.board, self.col_sums, self.row_sums = self.new(seed=seed)

    def new(
        self,
        seed: int | None = None,
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Generate a new board, column sums, and row sums.

        This method generates a new board, column sums, and row sums.
        The board is generated by sampling from a uniform distribution
        between ``low`` and ``high``. The column and row sums are
        generated by applying a deletion rate to the board.

        Args:
            seed (int | None, optional): The seed for random number
                generator. Defaults to ``None``.

        Returns:
            tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]: The
            generated board, column sums, and row sums.
        """
        # Apply seed
        np.random.seed(seed)

        # Generate new board
        board = np.random.randint(
            self.low,
            self.high,
            size=(self.K, self.K),
        )

        # Apply deletion rate
        mask = np.random.choice(
            [0, 1], size=board.shape, p=[self.deletion_rate, 1 - self.deletion_rate]
        )

        # Calculate column and row sums
        col_sums = np.sum(board * mask, axis=0)
        row_sums = np.sum(board * mask, axis=1)

        return board, col_sums, row_sums

    def evaluate(self, cell_mask: np.ndarray) -> float:
        """Evaluate the given cell mask.

        This method evaluates the given cell mask. The cell mask is a
        binary array that indicates which cells are to be removed from
        the board. The evaluation type determines how the fitness is
        calculated.

        Args:
            cell_mask (numpy.ndarray): The cell mask to evaluate. It
                should be a 1D array of length ``K * K``.

        Returns:
            float: The fitness of the given cell mask.
        """
        if self.evaluation_type == "mixed":
            # Initialize fitnesses
            fitnesses = []

            for eval_type in ["distance", "row_col", "cellular"]:
                # Evaluate the cell mask for the given evaluation type
                self.evaluation_type = eval_type
                fitnesses.append(self.evaluate(cell_mask))

            # Reset the evaluation type
            self.evaluation_type = "mixed"

            return np.mean(fitnesses)

        # Compute the new masked board
        board = self.board * cell_mask.reshape(self.K, self.K)

        # Calculate column and row sums
        col_sums = np.sum(board, axis=0)
        row_sums = np.sum(board, axis=1)

        if self.evaluation_type == "absolute":
            # Check if all row and all col sums are equal
            is_col_eq = np.all(col_sums == self.col_sums)
            is_row_eq = np.all(row_sums == self.row_sums)
            return int(is_col_eq and is_row_eq)
        elif self.evaluation_type == "distance":
            # Compute the absolute difference between the sums
            col_diffs = np.abs(col_sums - self.col_sums) / np.maximum(1, self.col_sums)
            row_diffs = np.abs(row_sums - self.row_sums) / np.maximum(1, self.row_sums)
            distance = (col_diffs.sum() + row_diffs.sum()) / 2
            raw_fitness = 1 / (1 + distance)
        elif self.evaluation_type == "row_col":
            # Compute the number of correct col and row sums
            col_correct = (col_sums == self.col_sums).sum()
            row_correct = (row_sums == self.row_sums).sum()
            raw_fitness = (col_correct + row_correct) / (self.K * 2)
        elif self.evaluation_type == "cellular":
            # Compute the number of correct col and row sums
            is_col_correct = col_sums == self.col_sums
            is_row_correct = row_sums == self.row_sums

            # Compute the raw fitness
            raw_fitness = (is_row_correct & is_col_correct[:, None]).sum() / (
                self.K**2
            )

        return raw_fitness

    def show(self, mask: np.ndarray = None, num_digits: int = 5):
        """Show the board.

        This method shows the board. The board can be masked to hide
        certain numbers.

        Args:
            mask (numpy.ndarray, optional): The mask to apply to the
                board. It should be a 1D array of length ``K * K`` or a
                2D array of shape ``(K, K)``. Defaults to ``None``,
                meaning no numbers will be hidden.
            num_digits (int, optional): The number of digits to show
                for each number. Defaults to 5.
        """
        # Initialize variables
        k, n = self.K, num_digits

        # Generate a mask to hide certain numbers in board
        mask = np.ones(self.board.shape) if mask is None else mask
        mask = mask.reshape(self.K, self.K) if mask.ndim == 1 else mask

        # Show the top border
        s = "+" + "-" * (n * k + k + 1) + "+\n"

        for i in range(k):
            # Generate printable values (mask if needed)
            values = (
                f"{self.board[i][j]:{n}}" if mask[i][j] else n * " " for j in range(k)
            )
            s += "| " + " ".join(values) + " | " + f"{self.row_sums[i]:n}\n"

        # Show the bottom border and column sums
        s += "+" + "-" * (n * k + k + 1) + "+\n"
        s += "  " + " ".join(f"{self.col_sums[i]:{n}}" for i in range(k))

        # Print
        print(s)

    def __call__(self, x: np.ndarray) -> float:
        return self.evaluate(x)

    def __repr__(self) -> str:
        return f"{self.evaluation_type}"
